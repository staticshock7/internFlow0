from time import sleep
from datetime import datetime
from paramiko import SSHClient, AutoAddPolicy
import socket
from getpass import getpass
from os import path
from concurrent.futures import ThreadPoolExecutor, as_completed
from re import findall, escape
# Terminal color codes
RED = "\033[31m"
GRN = "\033[32m"
YEL = "\033[33m"
MAG = "\033[35m"
CYN = "\033[36m"
RST = "\033[0m"


# prints the menu for the user
def menus():
    print(f"\nSelect your query type: \n")
    print(f"{MAG}1.{RST} Prefix \t+ \tSpecific IP")
    print(f"{MAG}2.{RST} Prefix \t+ \tREGEX IP")
    print(f"{MAG}3.{RST} Specific IP \t+ \tSuffix")
    print(f"{MAG}4.{RST} Regex IP \t+ \tSuffix")
    print(f"{MAG}5.{RST} Prefix \t+ \tSpecific IP \t+ Suffix")
    print(f"{MAG}6.{RST} Prefix \t+ \tRegex IP \t+ Suffix")
    print(f"{MAG}7.{RST} Enter \t{RED}Q{RST} \t to quit\n")

# recv_input function recieves the list of devices to be searched; or it receives theh path to the file containing a similar list
def dev_list():
    arr1 = []
    while True:
        var1 = input(f"{RED}>>>{RST} Enter devices (e.g. {MAG}XXXX4400 XXXX4401{RST}) or a file path with one device per line:\n\n{YEL}>{RST} ")
        try:
            if path.exists(var1):
                print("\n\n============= Path exists — Continuing... =============\n")
                with open(var1, "r") as file:
                    arr1 = [line.strip() for line in file if line.strip()]
                    break
        except Exception:
            print(f"\nIn valid path! Do not enclose the path in {RED}quotes!{RST}")
            continue
        else:
            try:
                arr1 = var1.strip().split() # removes the carriage returns, and adds each to a list
                break
            except Exception:
                print(f"{RED}>>>{RST} Invalid input! {RED}Use spaces between devices{RST} Try again.\n")
                continue
    print(f"\nDevices to be queried: {GRN}{arr1}{RST}")
        
    return arr1

def ssh_func(dev, key, cmd):
    ssh = SSHClient()
    ssh.set_missing_host_key_policy(AutoAddPolicy())

    try:       
        ssh.connect(f"{dev}.mgmt", username='admin', password=key)
        shell = ssh.invoke_shell()
        sleep(2)
        output = ""
        recv = ""
        shell.send(f"{cmd}\n")
        sleep(1)
        while True:
            if shell.recv_ready:
                recv = shell.recv(1024).decode()
                output += recv
                if '--MORE--' in recv:
                    shell.send(' ')
                    sleep(0.5)
            if recv.strip().endswith('>') or recv.strip().endswith('#'):
                break

    except socket.gaierror as e:
        print(f"\n{RED}Invalid Host:{RST} {dev}. Resolution failed: {e}")
        exit(1)
    except Exception as e:
        print(f"\n{RED}General connection failure:{RST} {e}")
        exit(1)
    finally:
        ssh.close()
    
    return output

def opt1():
    print(f"\nEnter the prefix string including the IP as seen from the {YEL}show config{RST} output.\n\n Example: {GRN}permit tcp 10.251.109.0{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    in2 = input(f"{YEL}>{RST} ")

    # get the ssh pass
    key = getpass('Enter the SSH password: ')
    # call the device list gathering function
    devs = dev_list()

    with ThreadPoolExecutor(max_workers=4) as exe:
        futures = {exe.submit(ssh_func, i, key, in2): i 
                   for i in devs
        }

        for future in as_completed(futures):
            device = futures[future]
            output = future.result()

            print(f"\n{MAG}{'='*25}{RST} {YEL}{device}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
        
            if in1 in output:
                print(f"✔️  {GRN}MATCH{RST} → {YEL}{device}{RST}")
            else:
                print(f"✖️  {RED}NO MATCH{RST} → {YEL}{device}{RST}")


def opt2():
    print(f"Enter the {RED}string prefix{RST} to be queried\n\n Example: {GRN}permit tcp{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    in2 = input(f"{YEL}>{RST} ")

    key = getpass('Enter the SSH password: ')

    devs = dev_list()

    with ThreadPoolExecutor(max_workers=4) as exe:
        futures = {exe.submit(ssh_func, i, key, in2): i for i in devs}

        for future in as_completed(futures):
            dev = futures[future]
            output = future.result()

            print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
            output = output.splitlines()

            for j in output:
                if (findall(fr"\b{in1}\s*((?:\d{{1,3}}\.){{3}}\d{{1,3}})\b", j)):
                    print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")



# may remove opt3, as it is functionally the same as opt1, but may be user friendly, conceptually
def opt3():
    print(f"Enter the suffix string including the IP for querying.\n\n Example: {GRN}0.0.0.0 any eq 22{RST}")
    in1 = input("> ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    in2 = input(f"{YEL}>{RST} ")

    key = getpass('Enter the SSH password: ')

    devs = dev_list()


    with ThreadPoolExecutor(max_workers=4) as exe:
        futures = {exe.submit(ssh_func, i, key, in2): i for i in devs}

        for future in as_completed(futures):
            dev = futures[future]
            output = future.result()

            print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

            if in1 in output:
                print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST}")
            else:
                print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")



# swapped the regex of opt2 around
def opt4():
    print(f"Enter the {RED}string suffix{RST} for querying.\n\n Example: {GRN}any eq 22{RST}")
    in1 = input("> ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    in2 = input(f"{YEL}>{RST} ")

    key = getpass('Enter the SSH password: ')

    devs = dev_list()


    with ThreadPoolExecutor(max_workers=4) as exe:
        futures = {exe.submit(ssh_func, i, key, in2): i for i in devs}

        for future in as_completed(futures):
            dev = futures[future]
            output = future.result()

            print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

            output = output.splitlines() # make a list of each line for indexing
            # regex for IPs
            for j in output:
                if (findall(fr"\b((?:\d{{1,3}}\.){{3}}\d{{1,3}})\s*{in1}\b", j)):
                    print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")



        
# also functionally the same as op1, but may be user friendly, conceptually
def opt5():
    print(f"Enter the {RED}entire string including the IP{RST} for querying.\n\n Example: {GRN}permit tcp 0.0.0.0 0.0.0.0 any eq 22{RST}")
    in1 = input("> ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    in2 = input(f"{YEL}>{RST} ")

    key = getpass('Enter the SSH password: ')

    devs = dev_list()

    with ThreadPoolExecutor(max_workers=4) as exe:
        futures = {exe.submit(ssh_func, i, key, in2): i for i in devs}

        for future in as_completed(futures):
            dev = futures[future]
            output = future.result()

            print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed  

            if in1 in output:
                print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST}")
            else:
                print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")          


def opt6():
    print(f"Enter the {RED}prefix string{RST} for querying.\n\n Example: {GRN}permit tcp{RST}")
    in1 = input("> ")
    print(f"Enter the {RED}suffix string{RST} for querying.\n\n Example: {GRN}any eq 22{RST}")
    in2 = input("> ")

    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    in3 = input(f"{YEL}>{RST} ")

    key = getpass('Enter the SSH password: ')

    devs = dev_list()

    with ThreadPoolExecutor(max_workers=4) as exe:
        futures = {exe.submit(ssh_func, i, key, in2): i for i in devs}

        for future in as_completed(futures):
            dev = futures[future]
            output = future.result()

            print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

            output = output.splitlines()
            # regex for IPs
            for j in output:
                if (findall(fr"{in1}\s*\b((?:\d{{1,3}}\.){{3}}\d{{1,3}})\s*{in2}\b", j)):
                    print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")


def main():

    while True:
        menus()
        choice1 = input(f"{YEL}>{RST} ")

        if choice1 == '1':
            opt1()
            break
        elif choice1 == '2':
            opt2()
            break
        elif choice1 == '3':
            opt3()
            break
        elif choice1 == '4':
            opt4()
            break
        elif choice1 == '5':
            opt5()
            break
        elif choice1 == '6':
            opt6()
            break
        elif choice1.lower() == 'q':
            print(f"\n\n {RED}Exiting...{RST}")
            break
        else:
            print(f"\nChoose a an option or use {RED}q{RST} to exit.")

if __name__ == "__main__":
    main()

    
