from time import sleep
from datetime import datetime
from paramiko import SSHClient, AutoAddPolicy
import socket
from getpass import getpass
from os import path, makedirs
from concurrent.futures import ThreadPoolExecutor, as_completed
from re import findall, sub
# Terminal color codes
RED = "\033[31m"
GRN = "\033[32m"
YEL = "\033[33m"
MAG = "\033[35m"
CYN = "\033[36m"
RST = "\033[0m"


# prints the menu for the user
def menus():
    print(f"\nSelect your query type: \n")
    print(f"{MAG}0.{RST} To run a {GRN}show config{RST} command against a possible good sample device.")
    print(f"{MAG}1.{RST} Prefix \t+ \tSpecific IP")
    print(f"{MAG}2.{RST} Prefix \t+ \t{CYN}RegEx IP{RST}")
    print(f"{MAG}3.{RST} Specific IP \t+ \tSuffix")
    print(f"{MAG}4.{RST} {CYN}RegEx IP{RST} \t+ \tSuffix")
    print(f"{MAG}5.{RST} Prefix \t+ \tSpecific IP \t+ Suffix")
    print(f"{MAG}6.{RST} Prefix \t+ \t{CYN}RegEx IP{RST} \t+ Suffix")
    print(f"{MAG}7.{RST} String search")
    print(f"{MAG}8.{RST} Download configs")
    print(f"\n{MAG}9.{RST} Enter \t{RED}Q{RST} \t to quit\n")

# dev_list function recieves the list of devices to be searched; or it receives theh path to the file containing a similar list
def dev_list():
    arr1 = []
    while True:
        var1 = input(f"{RED}>>>{RST} Enter devices (e.g. {MAG}XXXX4400 XXXX4401{RST}) or a file path with one device per line:\n\n{YEL}>{RST} ")
        try:
            if path.exists(var1):
                print("\n\n============= Path exists — Continuing... =============\n")
                with open(var1, "r") as file:
                    arr1 = [line.strip() for line in file if line.strip()]
                    break
        except Exception:
            print(f"\nIn valid path! Do not enclose the path in {RED}quotes!{RST}")
            continue
        else:
            try:
                arr1 = var1.strip().split() # removes the carriage returns, and adds each to a list
                break
            except Exception:
                print(f"{RED}>>>{RST} Invalid input! {RED}Use spaces between devices{RST} Try again.\n")
                continue
    print(f"\nDevices to be queried: {GRN}{arr1}{RST}")
        
    return arr1

def ssh_func(dev, key, cmd):
    ssh = SSHClient()
    ssh.set_missing_host_key_policy(AutoAddPolicy())

    try:       
        ssh.connect(f"{dev}.mgmt", username='admin', password=key)
        shell = ssh.invoke_shell()
        sleep(2)
        output = ""
        recv = ""
        shell.send(f"{cmd}\n")
        sleep(1)

        while True:
            if shell.recv_ready:
                recv = shell.recv(1024).decode()
                output += recv
                if '--MORE--' in recv or '--More--' in recv:
                    shell.send(' ')
                    sleep(0.5)
            if recv.strip().endswith('>') or recv.strip().endswith('#'):
                break

    except socket.gaierror as e:
        print(f"\n{RED}Invalid Host:{RST} {dev}. Resolution failed: {e}")
        return f"[ERR] {dev}: {e}"
    except Exception as e:
        print(f"\n{RED}General connection failure:{RST} {e}")
        return f"[ERR] {dev}: {e}"
    finally:
        ssh.close()
    
    return output


def opt0():
    dev = input(f"{RED}>>>{RST} Enter device (e.g. {MAG}LBEPOL4400{RST})\n{YEL}>{RST} ")
    key = getpass('Enter the SSH password: ')

    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    cmd1 = input(f"{YEL}>{RST} ")
    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        output = ssh_func(dev, key, cmd1)
        print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
        print(f"\n{CYN}{output}{RST}")


def opt1():
    print(f"\nEnter the prefix string including the IP as seen from the {YEL}show config{RST} output.\n\n Example (in yellow): {YEL}100 permit tcp{RST} {GRN}1.1.1.1 0.0.0.0 any eq 443{RST} || prefix can also be just one expected word directly before the IP: {YEL}tcp{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        devs = dev_list()
        # get the ssh pass
        key = getpass('Enter the SSH password: ')

        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i 
                    for i in devs
            }

            for future in as_completed(futures):
                device = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{device}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
            
                if in1 in output:
                    print(f"✔️  {GRN}MATCH{RST} → {YEL}{device}{RST}")
                else:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{device}{RST}")


def opt2():
    print(f"Enter the {RED}string prefix{RST} to be queried\n\nExample (in yellow): {YEL}100 permit tcp{RST} {GRN}1.1.1.1 0.0.0.0 any eq 443{RST}\n|| prefix can also be just one expected word {RED}directly before{RST} the IP: {YEL}tcp{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek.")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        devs = dev_list()
        key = getpass('Enter the SSH password: ')
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
                output = output.splitlines()
                matched = False # used for returning a singular NO MATCH if the for j loop returns no match
                for j in output:
                    if (findall(fr"\b{in1}\s*((?:\d{{1,3}}\.){{3}}\d{{1,3}})\b", j)):
                        print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True
                if not matched:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")

# may remove opt3, as it is functionally the same as opt1, but may be user friendly, conceptually
def opt3():
    print(f"Enter the suffix string including the IP for querying.\nExample (in yellow): {GRN}100 permit tcp 1.1.1.1 0.0.0.0{RST} {YEL}any eq 443{RST} || suffix can also be just one expected word {RED}directly after{RST} the IP: {YEL}any{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        devs = dev_list()
        key = getpass('Enter the SSH password: ')
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

                if in1 in output:
                    print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST}")
                else:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")


# swapped the regex of opt2 around
def opt4():
    print(f"Enter the {RED}string suffix{RST} for querying.\n\n Example: {GRN}any eq 22{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample (in yellow): {GRN}100 permit tcp 1.1.1.1 0.0.0.0{RST} {YEL}any eq 443{RST} || suffix can also be just one expected word {RED}directly after{RST} the IP: {YEL}any{RST}")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        devs = dev_list()
        key = getpass('Enter the SSH password: ')
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

                output = output.splitlines() # make a list of each line for indexing
                # regex for IPs

                matched = False # used for returning a singular NO MATCH if the for j loop returns no match

                for j in output:
                    if (findall(fr"\b((?:\d{{1,3}}\.){{3}}\d{{1,3}})\s*{in1}\b", j)):
                        print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True

                if not matched:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")

        
# also functionally the same as opt1, but may be user friendly, conceptually
def opt5():
    print(f"Enter the {RED}entire string including the IP{RST} for querying.\n Example: {YEL}permit tcp{RST}{GRN} 0.0.0.0 0.0.0.0 {RST}{YEL}any eq 22{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        devs = dev_list()
        key = getpass('Enter the SSH password: ')
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed  

                if in1 in output:
                    print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST}")
                else:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")

# for searching string + REGEX IP + string
def opt6():
    print(f"Enter the {RED}prefix string{RST} for querying.\n\n \n Example (in yellow): {YEL}permit tcp{RST}{GRN} 0.0.0.0 0.0.0.0 any eq 22{RST} \n || prefix can also be just one expected word {RED}directly before{RST} the IP")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}suffix string{RST} for querying.\n\n \n Example (in yellow): {GRN}permit tcp 0.0.0.0 0.0.0.0 {RST}{YEL}any eq 22{RST} \n || suffix can also be just one expected word {RED}directly after{RST} the IP")
    in2 = input(f"{YEL}>{RST} ")

    print(f"Enter the {RED}specific{RST} show command that contains the data you seek.")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        devs = dev_list()
        key = getpass('Enter the SSH password: ')
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

                output = output.splitlines()
                # regex for IPs

                matched = False

                for j in output:
                    if (findall(fr"{in1}\s*\b((?:\d{{1,3}}\.){{3}}\d{{1,3}})\s*{in2}\b", j)):
                        print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True
                if not matched:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")

# for searching strings
def opt7():
    print(f"Enter the string to be searched across the devices\n Example: {GRN}snmp-server enable service{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample ): {GRN}show config banner{RST}")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        devs = dev_list()
        key = getpass('Enter the SSH password: ')
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
                output = output.splitlines()
                matched = False # used for returning a singular NO MATCH if the for j loop returns no match
                for j in output:
                    if (findall(rf"\b(?:\w*)\s*{in1}\s*(?:\w*)\b", j)):
                        print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True
                if not matched:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}") 

# downloading the configs
def opt8():
    devs = dev_list()
    key = getpass('Enter the SSH password: ')
    cmd1 = input(f"Enter the show config command for your system:\n{YEL}>{RST} ")
    with ThreadPoolExecutor(max_workers=8) as exe:
        futures = {exe.submit(ssh_func, i, key, cmd1):i for i in devs}
    print("after threadpool")
    ### Creating a directory
    print(f"Would you like to store them in a new directory? [y/N]: ")
    in1 = input(f"{YEL}>{RST} ")
    if in1.lower() == 'y':
        print(f"Enter the new directory name: ")
        in2 = input(f"{YEL}>{RST} ")
        try:
            makedirs(in2, exist_ok=True)
            print(f"Created {GRN}{in2}{RST}")
        except Exception as e:
            print(f"Unable to create {RED}{in2}{RST} due to {RED}{e}{RST}")
    # End of Creating a directory

    for future in as_completed(futures):
        dev = futures[future]
        output = future.result()

        if in1.lower() == 'y':
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            try:
                with open(f"{in2}/{dev}_{timestamp}_conf.txt", "a") as file:
                    file.write(output)
                    print(f"\n{MAG}{'='*25}{RST} Written {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
            except Exception as e:
                print(f"Unable to access {RED}{file}{RST} due to {RED}{e}{RST}")
        else:
            try:
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                with open(f"{dev}_{timestamp}_conf.txt", "a") as file:
                    file.write(output)
                    print(f"\n{MAG}{'='*25}{RST} Written {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
            except Exception as e:
                print(f"Unable to access {RED}{file}{RST} due to {RED}{e}{RST}")

    ## check if the user would like to save the config to a folder


def main():

    while True:
        menus()
        choice1 = input(f"{YEL}>{RST} ")

        if choice1 == '0':
            opt0()
            sleep(3)
        elif choice1 == '1':
            opt1()
            sleep(5)
        elif choice1 == '2':
            opt2()
            sleep(5)
        elif choice1 == '3':
            opt3()
            sleep(5)
        elif choice1 == '4':
            opt4()
            sleep(5)
        elif choice1 == '5':
            opt5()
            sleep(5)
        elif choice1 == '6':
            opt6()
            sleep(5)
        elif choice1 == '7':
            opt7()
            sleep(5)
        elif choice1 == '8':
            opt8()
            sleep(5)
        elif choice1.lower() == 'q':
            print(f"\n\n {RED}Exiting...{RST}")
            sleep(1)
            break
        else:
            print(f"\nChoose a an option or use {RED}q{RST} to exit.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("Exiting")
