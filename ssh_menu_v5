from time import sleep
from datetime import datetime
from paramiko import SSHClient, AutoAddPolicy
from socket import gaierror
from getpass import getpass
from os import path, makedirs
from concurrent.futures import ThreadPoolExecutor, as_completed
from re import findall
# Terminal color codes
RED = "\033[31m"
GRN = "\033[32m"
YEL = "\033[33m"
MAG = "\033[35m"
CYN = "\033[36m"
RST = "\033[0m"
logged = False

# prints the menu for the user
def menus():
    print(f"\nSelect your query type: \n")
    print(f"{MAG}0.{RST} To run a {GRN}show config{RST} command against a possible good sample device.")
    print(f"{MAG}1.{RST} Prefix \t+ \tSpecific IP")
    print(f"{MAG}2.{RST} Prefix \t+ \t{CYN}RegEx IP{RST}")
    print(f"{MAG}3.{RST} Specific IP \t+ \tSuffix")
    print(f"{MAG}4.{RST} {CYN}RegEx IP{RST} \t+ \tSuffix")
    print(f"{MAG}5.{RST} Prefix \t+ \tSpecific IP \t+ Suffix")
    print(f"{MAG}6.{RST} Prefix \t+ \t{CYN}RegEx IP{RST} \t+ Suffix")
    print(f"{MAG}7.{RST} String search")
    print(f"{MAG}8.{RST} Download configs")
    print(f"\n{MAG}8.{RST} Enter \t{RED}N{RST} \t to renew device list!")
    print(f"{MAG}9.{RST} Enter \t{RED}Q{RST} \t to quit\n")

# dev_list function recieves the list of devices to be searched; or it receives theh path to the file containing a similar list
def dev_list():
    arr1 = []
    while True:
        var1 = input(f"{RED}>>>{RST} Enter devices (e.g. {MAG}LBEPOL4400 LBEPOL4401{RST}) or a file path with one device per line:\n\n{YEL}>{RST} ")
        try:
            if path.exists(var1):
                print("\n\n============= Path exists — Continuing... =============\n")
                with open(var1, "r") as file:
                    arr1 = [line.strip() for line in file if line.strip()]
                    break
        except Exception:
            print(f"\nIn valid path! Do not enclose the path in {RED}quotes!{RST}")
            continue
        else:
            try:
                arr1 = var1.strip().split() # removes the carriage returns, and adds each to a list
                break
            except Exception:
                print(f"{RED}>>>{RST} Invalid input! {RED}Use spaces between devices{RST} Try again.\n")
                continue
    print(f"\nDevices to be queried: {GRN}{arr1}{RST}")
        
    return arr1

def ssh_func(dev, key, cmd):
    ssh = SSHClient()
    ssh.set_missing_host_key_policy(AutoAddPolicy())

    try:       
        ssh.connect(f"{dev}.mgmt", username='admin', password=key)
        shell = ssh.invoke_shell()
        sleep(2)
        output = ""
        recv = ""
        shell.send(f"{cmd}\n")
        sleep(1)
        
        global logged
        logged = True
        while True:
            if shell.recv_ready:
                recv = shell.recv(1024).decode()
                output += recv
                if '--MORE--' in recv or '--More--' in recv:
                    shell.send(' ')
                    sleep(0.5)
            if recv.strip().endswith('>') or recv.strip().endswith('#'):
                break

    except gaierror as e:
        print(f"\n{RED}Invalid Host:{RST} {dev}. Resolution failed: {e}")
        return f"[ERR] {dev}: {e}"
    except Exception as e:
        print(f"\n{RED}General connection failure:{RST} {e}")
        return f"[ERR] {dev}: {e}"
    finally:
        ssh.close()

    return output

# sampling command output
def opt0():
    dev = input(f"{RED}>>>{RST} Enter device (e.g. {MAG}LBEPOL4400{RST})\n{YEL}>{RST} ")
    key = getpass('Enter the SSH password: ')

    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    cmd1 = input(f"{YEL}>{RST} ")
    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        output = ssh_func(dev, key, cmd1)
        print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
        print(f"\n{CYN}{output}{RST}")


def opt1(devs, key):
    print(f"\nEnter the prefix string including the IP as seen from the {YEL}show config{RST} output.\n\n Example (in yellow): {YEL}100 permit tcp{RST} {GRN}1.1.1.1 0.0.0.0 any eq 443{RST}\n|| prefix can also be just one expected word directly before the IP: {YEL}tcp{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i 
                    for i in devs
            }

            for future in as_completed(futures):
                device = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{device}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
            
                if in1 in output:
                    print(f"✔️  {GRN}MATCH{RST} → {YEL}{device}{RST}")
                else:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{device}{RST}")
    return devs, key

def opt2(devs, key):
    print(f"Enter the {RED}string prefix{RST} to be queried\n\nExample (in yellow): {YEL}100 permit tcp{RST} {GRN}1.1.1.1 0.0.0.0 any eq 443{RST}\n|| prefix can also be just one expected word {RED}directly before{RST} the IP: {YEL}tcp{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek.")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
                output = output.splitlines()
                matched = False # used for returning a singular NO MATCH if the for j loop returns no match
                for j in output:
                    if (findall(fr"\b{in1}\s*((?:\d{{1,3}}\.){{3}}\d{{1,3}})\b", j)):
                        print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True
                if not matched:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")
    return devs, key

# may remove opt3, as it is functionally the same as opt1, but may be user friendly, conceptually
def opt3(devs, key):
    print(f"Enter the suffix string including the IP for querying.\nExample (in yellow): {GRN}100 permit tcp 1.1.1.1 0.0.0.0{RST} {YEL}any eq 443{RST} || suffix can also be just one expected word {RED}directly after{RST} the IP: {YEL}any{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

                if in1 in output:
                    print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST}")
                else:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")
    return devs, key

# swapped the regex of opt2 around
def opt4(devs, key):
    print(f"Enter the {RED}string suffix{RST} for querying.\n\n Example: {GRN}any eq 22{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample (in yellow): {GRN}100 permit tcp 1.1.1.1 0.0.0.0{RST} {YEL}any eq 443{RST} || suffix can also be just one expected word {RED}directly after{RST} the IP: {YEL}any{RST}")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

                output = output.splitlines() # make a list of each line for indexing
                # regex for IPs

                matched = False # used for returning a singular NO MATCH if the for j loop returns no match

                for j in output:
                    if (findall(fr"\b((?:\d{{1,3}}\.){{3}}\d{{1,3}})\s*{in1}\b", j)):
                        print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True

                if not matched:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")
    return devs, key
        
# also functionally the same as opt1, but may be user friendly, conceptually
def opt5(devs, key):
    print(f"Enter the {RED}entire string including the IP{RST} for querying.\n Example: {YEL}permit tcp{RST}{GRN} 0.0.0.0 0.0.0.0 {RST}{YEL}any eq 22{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed  

                if in1 in output:
                    print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST}")
                else:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")
    return devs, key

# for searching string + REGEX IP + string
def opt6(devs, key):
    print(f"Enter the {RED}prefix string{RST} for querying.\n\n \n Example (in yellow): {YEL}permit tcp{RST}{GRN} 0.0.0.0 0.0.0.0 any eq 22{RST} \n || prefix can also be just one expected word {RED}directly before{RST} the IP")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}suffix string{RST} for querying.\n\n \n Example (in yellow): {GRN}permit tcp 0.0.0.0 0.0.0.0 {RST}{YEL}any eq 22{RST} \n || suffix can also be just one expected word {RED}directly after{RST} the IP")
    in2 = input(f"{YEL}>{RST} ")

    print(f"Enter the {RED}specific{RST} show command that contains the data you seek.")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

                output = output.splitlines()
                # regex for IPs

                matched = False

                for j in output:
                    if (findall(fr"{in1}\s*\b((?:\d{{1,3}}\.){{3}}\d{{1,3}})\s*{in2}\b", j)):
                        print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True
                if not matched:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}")
    return devs, key

# for searching strings
def opt7(devs, key):
    print(f"Enter the string to be searched across the devices\n Example: {GRN}snmp-server enable service{RST}")
    in1 = input(f"{YEL}>{RST} ")
    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample ): {GRN}show config banner{RST}")
    cmd1 = input(f"{YEL}>{RST} ")

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
                output = output.splitlines()
                matched = False # used for returning a singular NO MATCH if the for j loop returns no match
                for j in output:
                    if (findall(rf"\b(?:\w*)\s*{in1}\s*(?:\w*)\b", j)):
                        print(f"✔️  {GRN}MATCH{RST} → {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True
                if not matched:
                    print(f"✖️  {RED}NO MATCH{RST} → {YEL}{dev}{RST}") 
    return devs, key
# downloading the configs
def opt8(devs, key):
    cmd1 = input(f"Enter the show config command for your system:\n{YEL}>{RST} ")
    with ThreadPoolExecutor(max_workers=8) as exe:
        futures = {exe.submit(ssh_func, i, key, cmd1):i for i in devs}
    print("after threadpool")
    ### Creating a directory
    print(f"Would you like to store them in a new directory? [y/N]: ")
    in1 = input(f"{YEL}>{RST} ")
    if in1.lower() == 'y':
        print(f"Enter the new directory name: ")
        in2 = input(f"{YEL}>{RST} ")
        try:
            makedirs(in2, exist_ok=True)
            print(f"Created {GRN}{in2}{RST}")
        except Exception as e:
            print(f"Unable to create {RED}{in2}{RST} due to {RED}{e}{RST}")
    # End of Creating a directory

    for future in as_completed(futures):
        dev = futures[future]
        output = future.result()

        if in1.lower() == 'y':
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            try:
                with open(f"{in2}/{dev}_{timestamp}_conf.txt", "a") as file:
                    file.write(output)
                    print(f"\n{MAG}{'='*25}{RST} Written {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
            except Exception as e:
                print(f"Unable to access {RED}{file}{RST} due to {RED}{e}{RST}")
        else:
            try:
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                with open(f"{dev}_{timestamp}_conf.txt", "a") as file:
                    file.write(output)
                    print(f"\n{MAG}{'='*25}{RST} Written {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
            except Exception as e:
                print(f"Unable to access {RED}{file}{RST} due to {RED}{e}{RST}")

    return devs, key

# to store and call data from the dev_list() and the getpass()
class cached:
    def __init__(self):
        self.devs = None
        self.key = None
    def set_devs(self):
        self.devs = dev_list()
    def set_key(self):
        self.key = getpass('Enter the SSH passowrd: ')
    def get_devs(self):
        return self.devs
    def get_key(self):
        return self.key
    
cacheObj = cached() # guess I gotta leave an instance of the cached class out here for now

def cache(optX):
    # for selecting the correct opt function
    dict0 = {
        1: opt1,
        2: opt2,
        3: opt3,
        4: opt4,
        5: opt5,
        6: opt6,
        7: opt7,
        8: opt8
    }
    if logged == True:
        dict0[optX](cacheObj.get_devs(), cacheObj.get_key())
    else:
        cacheObj.set_devs()
        cacheObj.set_key()
        dict0[optX](cacheObj.get_devs(), cacheObj.get_key())

def main():

    while True:
        menus()
        choice1 = input(f"{YEL}>{RST} ")

        if choice1 == '0':
            if logged == True:
                opt7(cached_devs, cached_key)
            else:
                cached_devs, cached_key = opt7(devs=dev_list(), key=getpass('Enter the SSH password: '))
            sleep(2)
        elif choice1 == '1':
            cache(1)
            sleep(2)
        elif choice1 == '2':
            cache(2)
            sleep(2)
        elif choice1 == '3':
            cache(3)
            sleep(2)
        elif choice1 == '4':
            cache(4)
            sleep(2)
        elif choice1 == '5':
            cache(5)
            sleep(2)
        elif choice1 == '6':
            cache(6)
            sleep(2)
        elif choice1 == '7':
            cache(7)
            sleep(2)
        elif choice1 == '8':
            cache(8)
            sleep(2)
        elif choice1.lower() == 'n':
            print(f"\n\n {RED}Clearing the Device list!\n{RST}")
            cacheObj.set_devs()
            sleep(1)
        elif choice1.lower() == 'q':
            print(f"\n\n {RED}Exiting...{RST}")
            sleep(1)
            break
        else:
            print(f"\nChoose a an option or use {RED}Q{RST} to exit.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nKeyboard Interupt — Exiting")
