from time import sleep
from datetime import datetime
from paramiko import SSHClient, AutoAddPolicy
from socket import gaierror
from getpass import getpass
from os import path, makedirs
from concurrent.futures import ThreadPoolExecutor, as_completed
from re import findall
# Terminal color codes
RED = "\033[31m"
GRN = "\033[32m"
YEL = "\033[33m"
MAG = "\033[35m"
CYN = "\033[36m"
RST = "\033[0m"
logged = False

# prints the menu for the user
def menus():
    print(f"\n{MAG}{'='*30} DEVICE QUERY MENU {'='*30}{RST}")
    print(f"""
{GRN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\tâ•—
â•‘ 0. ðŸ”  Run a {YEL}show{RST} command on a single test device[{RED}Not Repeatable{RST}]\tâ•‘
â•‘ 1. ðŸ§©  Match {CYN}prefix{RST} string directly {YEL}before{RST} an IP (exact match)\tâ•‘
â•‘ 2. ðŸ”¬  Match {CYN}prefix{RST} followed by an IP using {YEL}regex{RST}\t\t\tâ•‘
â•‘ 3. ðŸ§©  Match {CYN}suffix{RST} string directly {YEL}after{RST} an IP (exact match)\t\tâ•‘
â•‘ 4. ðŸ”¬  Match IP followed by {CYN}suffix{RST} using {YEL}regex{RST}\t\t\tâ•‘
â•‘ 5. ðŸŽ¯  Match full line: {CYN}prefix + IP + suffix{RST} (exact match)\t\tâ•‘
â•‘ 6. ðŸ§   Match {CYN}prefix + {YEL}regex IP{RST} + suffix{RST} (flexible match)\t\tâ•‘
â•‘ 7. ðŸ”Ž  Search for any {CYN}string{RST} in command output\t\t\tâ•‘
â•‘ 8. ðŸ“¥  Download full config output to files\t[{RED}Not Repeatable{RST}]\tâ•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\tâ•

{YEL}Other Commands:{RST}
  {CYN}R{RST} â€“ ðŸ”  Repeat the last function
  {CYN}N{RST} â€“ ðŸ”„  Load a new device list
  {CYN}Q{RST} â€“ âŒ  Quit the program
""")

# dev_list function recieves the list of devices to be searched; or it receives theh path to the file containing a similar list
def dev_list():
    arr1 = []
    while True:
        var1 = input(f"{RED}>>>{RST} Enter devices (e.g. {CYN}XXXX4400 XXXX4401{RST}) or a file path with one device per line:\n\n{YEL}>{RST} ")
        try:
            if path.exists(var1):
                print(f"\n\n{"="*25} Path exists â€” Continuing... {"="*25}\n")
                with open(var1, "r") as file:
                    arr1 = [line.strip() for line in file if line.strip()]
                    break
        except Exception:
            print(f"\nIn valid path! Do not enclose the path in {RED}quotes!{RST}")
            continue
        else:
            try:
                arr1 = var1.strip().split() # removes the carriage returns, and adds each to a list
                break
            except Exception:
                print(f"{RED}>>>{RST} Invalid input! {RED}Use spaces between devices{RST} Try again.\n")
                continue
    print(f"\nDevices to be queried: {GRN}{arr1}{RST}")
        
    return arr1

def ssh_func(dev, key, cmd):
    ssh = SSHClient()
    ssh.set_missing_host_key_policy(AutoAddPolicy())

    try:       
        ssh.connect(f"{dev}.mgmt", username='admin', password=key)
        shell = ssh.invoke_shell()
        sleep(2)
        output = ""
        recv = ""
        shell.send(f"{cmd}\n")
        sleep(1)
        
        global logged
        logged = True
        while True:
            if shell.recv_ready:
                recv = shell.recv(1024).decode()
                output += recv
                if '--MORE--' in recv or '--More--' in recv:
                    shell.send(' ')
                    sleep(0.5)
            if recv.strip().endswith('>') or recv.strip().endswith('#'):
                break

    except gaierror as e:
        print(f"\n{RED}Invalid Host:{RST} {dev}. Resolution failed: {e}")
        return f"[ERR] {dev}: {e}"
    except Exception as e:
        print(f"\n{RED}General connection failure:{RST} {e}")
        return f"[ERR] {dev}: {e}"
    finally:
        ssh.close()

    return output

# sampling command output
def opt0():
    dev = input(f"{RED}>>>{RST} Enter device (e.g. {CYN}LBEPOL4400{RST})\n{YEL}>{RST} ")
    key = getpass('Enter the SSH password: ')

    print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
    cmd1 = input(f"{YEL}>{RST} ")
    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        output = ssh_func(dev, key, cmd1)
        print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
        print(f"\n{CYN}{output}{RST}")
    global logged
    logged = False

class repeat:
    def __init__(self):
        self.string1 = None
        self.string2 = None
        self.cmd = None
        self.func = None

    # self explanatory
    def set_string1(self, string1):
        self.string1 = string1
    def set_string2(self, string2):
        self.string2 = string2
    def set_cmd(self, cmd1):
        self.cmd = cmd1
    def set_func(self,func):
        self.func = func

    def get_string1(self):
        return self.string1
    def get_string2(self):
        return self.string2
    def get_cmd(self):
        return self.cmd
    def get_func(self):
        return self.func

# global instance of the repeat class
repeats = repeat()

def repeater():
    if repeats.get_func() == 1:
        cache(1)
        sleep(2)
    elif repeats.get_func() == 2:
        cache(2)
        sleep(2)
    elif repeats.get_func() == 3:
        cache(3)
        sleep(2)
    elif repeats.get_func() == 4:
        cache(4)
        sleep(2)
    elif repeats.get_func() == 5:
        cache(5)
        sleep(2)
    elif repeats.get_func() == 6:
        cache(6)
        sleep(2)
    elif repeats.get_func() == 7:
        cache(7)
        sleep(2)
    elif repeats.get_func() == 8:
        print(f"\n{YEL}Unable to repeat this function!")
        sleep(2)
    else:
        print(f"\n{RED}There is nothing available to repeat, right now!\n")
    

def opt1(devs, key):
    # checks the instance for Boolean state of get_string
    if repeats.get_string1() and repeats.get_func() == 1:
        # print("This ran")
        # print(bool(repeats.get_string1))
        in1 = repeats.get_string1() # assigns values for these variables as repetition
        cmd1 = repeats.get_cmd()
    else:
        print(f"\nEnter the prefix string including the IP as seen from the {YEL}show config{RST} output.\n\n Example (in yellow): {YEL}100 permit tcp{RST} {GRN}1.1.1.1 0.0.0.0 any eq 443{RST}\n|| prefix can also be just one expected word directly before the IP: {YEL}tcp{RST}")
        in1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(in1) # stores the input as data for the obj instance
        print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
        cmd1 = input(f"{YEL}>{RST} ")
        repeats.set_cmd(cmd1)# stores the input as data for the obj instance

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i 
                    for i in devs
            }

            for future in as_completed(futures):
                device = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{device}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
            
                if in1 in output:
                    print(f"âœ”ï¸  {GRN}MATCH{RST} â†’ {YEL}{device}{RST}")
                else:
                    print(f"âœ–ï¸  {RED}NO MATCH{RST} â†’ {YEL}{device}{RST}")
    return devs, key

def opt2(devs, key):
    if repeats.get_string1 and repeats.get_func() == 2:
        in1 = repeats.get_string1()
        cmd1 = repeats.get_cmd()
    else: 
        print(f"Enter the {RED}string prefix{RST} to be queried\n\nExample (in yellow): {YEL}100 permit tcp{RST} {GRN}1.1.1.1 0.0.0.0 any eq 443{RST}\n|| prefix can also be just one expected word {RED}directly before{RST} the IP: {YEL}tcp{RST}")
        in1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(in1)
        print(f"Enter the {RED}specific{RST} show command that contains the data you seek.")
        cmd1 = input(f"{YEL}>{RST} ")
        repeats.set_cmd(cmd1)

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
                output = output.splitlines()
                matched = False # used for returning a singular NO MATCH if the for j loop returns no match
                for j in output:
                    if (findall(fr"\b{in1}\s*((?:\d{{1,3}}\.){{3}}\d{{1,3}})\b", j)):
                        print(f"âœ”ï¸  {GRN}MATCH{RST} â†’ {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True
                if not matched:
                    print(f"âœ–ï¸  {RED}NO MATCH{RST} â†’ {YEL}{dev}{RST}")
    return devs, key

# may remove opt3, as it is functionally the same as opt1, but may be user friendly, conceptually
def opt3(devs, key):
    if repeats.get_string1 and repeats.get_func() == 3:
        in1 = repeats.get_string1()
        cmd1 = repeats.get_cmd()
    else: 
        print(f"Enter the suffix string including the IP for querying.\nExample (in yellow): {GRN}100 permit tcp 1.1.1.1 0.0.0.0{RST} {YEL}any eq 443{RST} || suffix can also be just one expected word {RED}directly after{RST} the IP: {YEL}any{RST}")
        in1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(in1)
        print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
        cmd1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(cmd1)

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

                if in1 in output:
                    print(f"âœ”ï¸  {GRN}MATCH{RST} â†’ {YEL}{dev}{RST}")
                else:
                    print(f"âœ–ï¸  {RED}NO MATCH{RST} â†’ {YEL}{dev}{RST}")
    return devs, key

# swapped the regex of opt2 around
def opt4(devs, key):
    if repeats.get_string1 and repeats.get_func() == 4:
        in1 = repeats.get_string1()
        cmd1 = repeats.get_cmd()
    else:     
        print(f"Enter the {RED}string suffix{RST} for querying.\n\n Example: {GRN}any eq 22{RST}")
        in1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(in1)
        print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample (in yellow): {GRN}100 permit tcp 1.1.1.1 0.0.0.0{RST} {YEL}any eq 443{RST} || suffix can also be just one expected word {RED}directly after{RST} the IP: {YEL}any{RST}")
        cmd1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(cmd1)

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

                output = output.splitlines() # make a list of each line for indexing
                # regex for IPs

                matched = False # used for returning a singular NO MATCH if the for j loop returns no match

                for j in output:
                    if (findall(fr"\b((?:\d{{1,3}}\.){{3}}\d{{1,3}})\s*{in1}\b", j)):
                        print(f"âœ”ï¸  {GRN}MATCH{RST} â†’ {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True

                if not matched:
                    print(f"âœ–ï¸  {RED}NO MATCH{RST} â†’ {YEL}{dev}{RST}")
    return devs, key
        
# also functionally the same as opt1, but may be user friendly, conceptually
def opt5(devs, key):
    if repeats.get_string1 and repeats.get_func() == 5:
        in1 = repeats.get_string1()
        cmd1 = repeats.get_cmd()
    else:     
        print(f"Enter the {RED}entire string including the IP{RST} for querying.\n Example: {YEL}permit tcp{RST}{GRN} 0.0.0.0 0.0.0.0 {RST}{YEL}any eq 22{RST}")
        in1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(in1)
        print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample: {GRN}show config ip access-list{RST}")
        cmd1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(cmd1)

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed  

                if in1 in output:
                    print(f"âœ”ï¸  {GRN}MATCH{RST} â†’ {YEL}{dev}{RST}")
                else:
                    print(f"âœ–ï¸  {RED}NO MATCH{RST} â†’ {YEL}{dev}{RST}")
    return devs, key

# for searching string + REGEX IP + string
def opt6(devs, key):
    if repeats.get_string1 and repeats.get_func() == 6:
        in1 = repeats.get_string1()
        in2 = repeats.get_string2()
        cmd1 = repeats.get_cmd()
    else: 
        print(f"Enter the {RED}prefix string{RST} for querying.\n\n \n Example (in yellow): {YEL}permit tcp{RST}{GRN} 0.0.0.0 0.0.0.0 any eq 22{RST} \n || prefix can also be just one expected word {RED}directly before{RST} the IP")
        in1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(in1)
        print(f"Enter the {RED}suffix string{RST} for querying.\n\n \n Example (in yellow): {GRN}permit tcp 0.0.0.0 0.0.0.0 {RST}{YEL}any eq 22{RST} \n || suffix can also be just one expected word {RED}directly after{RST} the IP")
        in2 = input(f"{YEL}>{RST} ")
        repeats.set_string2(in2)
        print(f"Enter the {RED}specific{RST} show command that contains the data you seek.")
        cmd1 = input(f"{YEL}>{RST} ")
        repeats.set_cmd(cmd1)

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed

                output = output.splitlines()
                # regex for IPs

                matched = False

                for j in output:
                    if (findall(fr"{in1}\s*\b((?:\d{{1,3}}\.){{3}}\d{{1,3}})\s*{in2}\b", j)):
                        print(f"âœ”ï¸  {GRN}MATCH{RST} â†’ {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True
                if not matched:
                    print(f"âœ–ï¸  {RED}NO MATCH{RST} â†’ {YEL}{dev}{RST}")
    return devs, key

# for searching strings
def opt7(devs, key):
    if repeats.get_string1 and repeats.get_func() == 7:
        in1 = repeats.get_string1()
        cmd1 = repeats.get_cmd()
    else: 
        print(f"Enter the string to be searched across the devices\n Example: {GRN}snmp-server enable service{RST}")
        in1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(in1)
        print(f"Enter the {RED}specific{RST} show command that contains the data you seek. \nExample ): {GRN}show config banner{RST}")
        cmd1 = input(f"{YEL}>{RST} ")
        repeats.set_string1(cmd1)

    if 'show' not in cmd1:
        print(f"\n\nPlease enter a {RED}show{RST} command only!\n\n")
        sleep(4)
        main()
    else:
        with ThreadPoolExecutor(max_workers=8) as exe:
            futures = {exe.submit(ssh_func, i, key, cmd1): i for i in devs}

            for future in as_completed(futures):
                dev = futures[future]
                output = future.result()

                print(f"\n{MAG}{'='*25}{RST} {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
                output = output.splitlines()
                matched = False # used for returning a singular NO MATCH if the for j loop returns no match
                for j in output:
                    if (findall(rf"\b(?:\w*)\s*{in1}\s*(?:\w*)\b", j)):
                        print(f"âœ”ï¸  {GRN}MATCH{RST} â†’ {YEL}{dev}{RST} {RED}>>>{RST} {j}")
                        matched = True
                if not matched:
                    print(f"âœ–ï¸  {RED}NO MATCH{RST} â†’ {YEL}{dev}{RST}") 
    return devs, key
# downloading the configs
def opt8(devs, key):
    cmd1 = input(f"Enter the show config command for your system:\n{YEL}>{RST} ")
    with ThreadPoolExecutor(max_workers=8) as exe:
        futures = {exe.submit(ssh_func, i, key, cmd1):i for i in devs}
    print("after threadpool")
    ### Creating a directory
    print(f"Would you like to store them in a new directory? [y/N]: ")
    in1 = input(f"{YEL}>{RST} ")
    if in1.lower() == 'y':
        print(f"Enter the new directory name: ")
        in2 = input(f"{YEL}>{RST} ")
        try:
            makedirs(in2, exist_ok=True)
            print(f"Created {GRN}{in2}{RST}")
        except Exception as e:
            print(f"Unable to create {RED}{in2}{RST} due to {RED}{e}{RST}")
    # End of Creating a directory

    for future in as_completed(futures):
        dev = futures[future]
        output = future.result()

        if in1.lower() == 'y':
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            try:
                with open(f"{in2}/{dev}_{timestamp}_conf.txt", "a") as file:
                    file.write(output)
                    print(f"\n{MAG}{'='*25}{RST} Written {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
            except Exception as e:
                print(f"Unable to access {RED}{file}{RST} due to {RED}{e}{RST}")
        else:
            try:
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                with open(f"{dev}_{timestamp}_conf.txt", "a") as file:
                    file.write(output)
                    print(f"\n{MAG}{'='*25}{RST} Written {YEL}{dev}{RST} {MAG}{'='*25}{RST}") # banner for each device results printed
            except Exception as e:
                print(f"Unable to access {RED}{file}{RST} due to {RED}{e}{RST}")

    return devs, key

# to store and call data from the dev_list() and the getpass()
class cached:
    def __init__(self):
        self.devs = None
        self.key = None
    def set_devs(self):
        self.devs = dev_list()
    def set_key(self):
        self.key = getpass('Enter the SSH passowrd: ')
    def get_devs(self):
        return self.devs
    def get_key(self):
        return self.key
    
cacheObj = cached() # guess I gotta leave an instance of the cached class out here for now

def cache(optX):
    # for selecting the correct opt function
    dict0 = {
        1: opt1,
        2: opt2,
        3: opt3,
        4: opt4,
        5: opt5,
        6: opt6,
        7: opt7,
        8: opt8
    }
    if logged == True:
        dict0[optX](cacheObj.get_devs(), cacheObj.get_key())
    else:
        cacheObj.set_devs()
        cacheObj.set_key()
        dict0[optX](cacheObj.get_devs(), cacheObj.get_key())

def main():
    while True:
        menus()
        choice1 = input(f"{YEL}>{RST} ")
        if choice1 == '0':
            opt0()
            sleep(2)
        elif choice1 == '1':
            cache(1)
            sleep(2)
            repeats.set_func(1)
        elif choice1 == '2':
            cache(2)
            sleep(2)
            repeats.set_func(2)
        elif choice1 == '3':
            cache(3)
            sleep(2)
            repeats.set_func(3)
        elif choice1 == '4':
            cache(4)
            sleep(2)
            repeats.set_func(4)
        elif choice1 == '5':
            cache(5)
            sleep(2)
            repeats.set_func(5)
        elif choice1 == '6':
            cache(6)
            sleep(2)
            repeats.set_func(6)
        elif choice1 == '7':
            cache(7)
            sleep(2)
            repeats.set_func(7)
        elif choice1 == '8':
            cache(8)
            sleep(2)
            repeats.set_func(8)
        elif choice1.lower() == 'r':
            repeater()
        elif choice1.lower() == 'n':
            print(f"\n\n {RED}Clearing the Device list!\n{RST}")
            cacheObj.set_devs()
            sleep(1)
        elif choice1.lower() == 'q':
            print(f"\n\n {RED}Exiting...{RST}")
            sleep(1)
            break
        else:
            print(f"\nChoose a an option or use {RED}Q{RST} to exit.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nKeyboard Interupt â€” Exiting")
